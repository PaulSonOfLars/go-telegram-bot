package main

import (
	"errors"
	"fmt"
	"strings"
	"text/template"
)

// TODO: dont hardcode; obtain these from reply_markup fields.
var replyMarkupTypes = []string{
	"InlineKeyboardMarkup",
	"ReplyKeyboardMarkup",
	"ReplyKeyboardRemove",
	"ForceReply",
}

var (
	genericInterfaceTmpl          = template.Must(template.New("genericInterface").Parse(genericInterfaceMethod))
	inputMediaInterfaceTmpl       = template.Must(template.New("inputMediaInterface").Parse(inputMediaInterfaceMethod))
	customMarshalTmpl             = template.Must(template.New("customMarshal").Parse(customMarshal))
	customConstStringFieldTmpl    = template.Must(template.New("customConstStringField").Parse(customConstStringField))
	customUnmarshalTmpl           = template.Must(template.New("customUnmarshal").Parse(customUnmarshal))
	customStructUnmarshalTmpl     = template.Must(template.New("customStructUnmarshal").Parse(customStructUnmarshal))
	customStructUnmarshalCaseTmpl = template.Must(template.New("customStructUnmarshalCase").Parse(customStructUnmarshalCase))
)

func generateTypes(d APIDescription) error {
	file := strings.Builder{}
	file.WriteString(`
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Regen by running 'go generate' in the repo root.

package gotgbot

import (
	"encoding/json"
	"fmt"
	"io"
	"errors"
)
`)

	// the reply_markup field is weird; this allows it to support multiple types.
	file.WriteString(generateGenericInterfaceType("ReplyMarkup", true))

	for _, tgTypeName := range orderedTgTypes(d) {
		tgType := d.Types[tgTypeName]

		typeDef, err := generateTypeDef(d, tgType)
		if err != nil {
			return fmt.Errorf("failed to generate type definition of %s: %w", tgTypeName, err)
		}

		file.WriteString(typeDef)
	}

	return writeGenToFile(file, "gen_types.go")
}

func generateTypeDef(d APIDescription, tgType TypeDescription) (string, error) {
	typeDef := strings.Builder{}

	for idx, d := range tgType.Description {
		text := d
		if idx == 0 {
			text = tgType.Name + " " + d
		}

		typeDef.WriteString("\n// " + text)
	}

	typeDef.WriteString("\n// " + tgType.Href)

	if len(tgType.Fields) == 0 {
		switch tgType.Name {
		case tgTypeInputMedia:
			typeDef.WriteString(generateInputMediaInterfaceType(tgType.Name, tgType))

		case tgTypeBotCommandScope:
			typeDef.WriteString(generateConstFieldInterfaceType(tgType.Name, "type"))

		case tgTypeChatMember:
			typeDef.WriteString(generateConstFieldInterfaceType(tgType.Name, "status"))

		case tgTypeCallbackGame,
			tgTypeInlineQueryResult,
			tgTypeInputFile,
			tgTypeInputMessageContent,
			tgTypePassportElementError:
			typeDef.WriteString(generateGenericInterfaceType(tgType.Name, len(tgType.Subtypes) != 0))

		case tgTypeVoiceChatStarted:
			// VoiceChatStarted is actually just empty, this is legitimate
			typeDef.WriteString("\ntype " + tgType.Name + " struct{}")

		default:
			return "", fmt.Errorf("unknown type %s has no fields - please check if this requires implementation", tgType.Name)
		}

		// Interface types need to be unmarshalled in a specific way to be received by the API.
		// To do this, we need to define a custom UnmarshalJSON method unmarshal the right bits.
		if len(tgType.Subtypes) > 0 && tgType.sentByAPI(d) {
			unmarshalFunc, err := interfaceUnmarshalFunc(d, tgType)
			if err != nil {
				return "", fmt.Errorf("unable to generate interface unmarshal function")
			}
			if unmarshalFunc != "" {
				typeDef.WriteString("\n\n" + unmarshalFunc)
			}
		}

		return typeDef.String(), nil

	} else {
		typeFields, err := generateTypeFields(d, tgType)
		if err != nil {
			return "", err
		}

		if typeFields == "" {
			typeDef.WriteString("\ntype " + tgType.Name + " struct{}")
		} else {
			typeDef.WriteString("\ntype " + tgType.Name + " struct {")
			typeDef.WriteString(typeFields)
			typeDef.WriteString("\n}")
		}

		s, err := setupCustomUnmarshal(d, tgType)
		if err != nil {
			return "", err
		}
		typeDef.WriteString(s)
	}

	interfaces, err2 := generateParentTypeInterfaces(d, tgType)
	if err2 != nil {
		return "", err2
	}

	typeDef.WriteString(interfaces)

	return typeDef.String(), nil
}

// Incoming types which marshal into interfaces need special handling to make sure the interfaces are
// populated correctly.
func setupCustomUnmarshal(d APIDescription, tgType TypeDescription) (string, error) {
	var fields []customUnmarshalFieldData
	generateCustomMarshal := false
	for idx, f := range tgType.Fields {
		prefType, err := f.getPreferredType()
		if err != nil {
			return "", err
		}

		if HasSubtypes(d, prefType) && d.Types[prefType].getConstantField(d) != "" {
			generateCustomMarshal = true
		}

		if idx == 0 && len(tgType.SubtypeOf) > 0 && (f.Name == "type" || f.Name == "status") {
			continue
		}

		if isTgType(d, prefType) && !f.Required {
			prefType = "*" + prefType
		}

		fields = append(fields, customUnmarshalFieldData{
			Name:    snakeToTitle(f.Name),
			Custom:  len(d.Types[prefType].Subtypes) > 0,
			Type:    prefType,
			JSONTag: fmt.Sprintf("`json:\"%s\"`", f.Name),
		})
	}

	if !generateCustomMarshal {
		return "", nil
	}

	bd := strings.Builder{}
	err := customUnmarshalTmpl.Execute(&bd, customUnmarshalData{
		Type:   tgType.Name,
		Fields: fields,
	})
	if err != nil {
		return "", err
	}
	return bd.String(), nil
}

func generateParentTypeInterfaces(d APIDescription, tgType TypeDescription) (string, error) {
	typeInterfaces := strings.Builder{}
	for _, parentType := range tgType.SubtypeOf {
		switch parentType {
		case tgTypeInputMedia:
			// InputMedia items need a custom marshaller to handle the "type" field
			typeName := strings.TrimPrefix(tgType.Name, tgTypeInputMedia)

			constantField := tgType.Fields[0].Name

			err := customConstStringFieldTmpl.Execute(&typeInterfaces, customConstStringData{
				Type:              tgType.Name,
				ConstantFieldName: strings.Title(constantField),
				ConstantValueName: titleToSnake(typeName),
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate custom const field function for %s: %w", tgType.Name, err)
			}

			err = customMarshalTmpl.Execute(&typeInterfaces, customMarshalData{
				Type:                  tgType.Name,
				ConstantFieldName:     strings.Title(constantField),
				ConstantJSONFieldName: constantField,
				ConstantValueName:     titleToSnake(typeName),
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate custom marshal function for %s: %w", tgType.Name, err)
			}

			// We also need to setup the interface method
			err = inputMediaInterfaceTmpl.Execute(&typeInterfaces, interfaceMethodData{
				Type:       tgType.Name,
				ParentType: parentType,
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate %s interface methods for %s: %w", parentType, tgType.Name, err)
			}

		case tgTypeInlineQueryResult, tgTypeBotCommandScope, tgTypeChatMember:
			err := constantFieldGenerator(d, tgType, &typeInterfaces, parentType)
			if err != nil {
				return "", err
			}

		case tgTypeInputMessageContent, tgTypePassportElementError:
			err := genericInterfaceTmpl.Execute(&typeInterfaces, interfaceMethodData{
				Type:       tgType.Name,
				ParentType: parentType,
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate %s interface methods for %s: %w", parentType, tgType.Name, err)
			}

		default:
			return "", fmt.Errorf("unable to handle parent type %s while generating for type %s\n", parentType, tgType.Name)
		}
	}

	for _, t := range replyMarkupTypes {
		if tgType.Name == t {
			err := genericInterfaceTmpl.Execute(&typeInterfaces, interfaceMethodData{
				Type:       tgType.Name,
				ParentType: "ReplyMarkup",
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate replymarkup interface methods for %s: %w", tgType.Name, err)
			}

			break
		}
	}

	return typeInterfaces.String(), nil
}

func interfaceUnmarshalFunc(d APIDescription, tgType TypeDescription) (string, error) {
	constantField := strings.Title(tgType.getConstantField(d))
	if constantField == "" {
		// If we dont have a constant field, we can't setup the unmarshaller.
		return "", errors.New("cant generate custom unmarshal func without a common field")
	}

	var cases []string
	caseBd := strings.Builder{}
	for _, subTypeName := range tgType.Subtypes {
		shortName := d.Types[subTypeName].getTypeNameFromParent(tgType.Name)
		err := customStructUnmarshalCaseTmpl.Execute(&caseBd, customStructUnmarshalCaseData{
			ConstantFieldName: titleToSnake(shortName),
			TypeName:          subTypeName,
		})
		if err != nil {
			return "", err
		}

		cases = append(cases, caseBd.String())
		caseBd.Reset()
	}

	bd := strings.Builder{}
	err := customStructUnmarshalTmpl.Execute(&bd, customStructUnmarshalData{
		UnmarshalFuncName: "unmarshal" + tgType.Name,
		ParentType:        tgType.Name,
		ConstantFieldName: constantField,
		CaseStatements:    cases,
	})
	if err != nil {
		return "", err
	}

	return bd.String(), nil
}

func constantFieldGenerator(d APIDescription, tgType TypeDescription, typeInterfaces *strings.Builder, parentType string) error {
	// Some items need a custom marshaller to handle the "type" field
	typeName := tgType.getTypeNameFromParent(parentType)

	constantField := tgType.getConstantField(d)

	err := customConstStringFieldTmpl.Execute(typeInterfaces, customConstStringData{
		Type:              tgType.Name,
		ConstantFieldName: strings.Title(constantField),
		ConstantValueName: titleToSnake(typeName),
	})
	if err != nil {
		return fmt.Errorf("failed to generate custom const field function for %s: %w", tgType.Name, err)
	}

	err = customMarshalTmpl.Execute(typeInterfaces, customMarshalData{
		Type:                  tgType.Name,
		ConstantFieldName:     strings.Title(constantField),
		ConstantJSONFieldName: constantField,
		ConstantValueName:     titleToSnake(typeName),
	})
	if err != nil {
		return fmt.Errorf("failed to generate custom marshal function for %s: %w", tgType.Name, err)
	}

	err = genericInterfaceTmpl.Execute(typeInterfaces, interfaceMethodData{
		Type:       tgType.Name,
		ParentType: parentType,
	})
	if err != nil {
		return fmt.Errorf("failed to generate %s interface methods for %s: %w", parentType, tgType.Name, err)
	}
	return nil
}

func generateTypeFields(d APIDescription, tgType TypeDescription) (string, error) {
	typeFields := strings.Builder{}
	for _, f := range tgType.Fields {
		fieldType, err := f.getPreferredType()
		if err != nil {
			return "", fmt.Errorf("failed to get preferred type: %w", err)
		}

		if isSubtypeOf(tgType, tgTypeInlineQueryResult) {
			// we don't write the type field since it isn't something that should be customised. This is set in the custom marshaller.
			if f.Name == "type" {
				continue
			}
		} else if isSubtypeOf(tgType, tgTypeInputMedia) {
			// we don't write the type field since it isn't something that should be customised. This is set in the custom marshaller.
			if f.Name == "type" {
				continue
			}

			// We manually override the media field to have InputFile type on all inputmedia to allow reuse of fileuploads logic.
			if f.Name == "media" {
				fieldType = tgTypeInputFile
			}
		} else if isSubtypeOf(tgType, tgTypeChatMember) {
			// we don't write the status field since it isn't something that should be customised. This is set in the custom marshaller.
			if f.Name == "status" {
				continue
			}
		} else if isSubtypeOf(tgType, tgTypeBotCommandScope) {
			// we don't write the type field since it isn't something that should be customised. This is set in the custom marshaller.
			if f.Name == "type" {
				continue
			}
		}

		if isTgType(d, fieldType) && !f.Required {
			fieldType = "*" + fieldType
		}

		typeFields.WriteString("\n// " + f.Description)
		typeFields.WriteString("\n" + snakeToTitle(f.Name) + " " + fieldType + " `json:\"" + f.Name + ",omitempty\"`")
	}

	return typeFields.String(), nil
}

func generateInputMediaInterfaceType(name string, tgType TypeDescription) string {
	if len(tgType.Subtypes) != 0 {
		return fmt.Sprintf(`
type %s interface{
	Type() string
	%sParams(string, map[string]NamedReader) ([]byte, error)
}`, name, name)
	}

	return "\ntype " + name + " interface{}"
}

func generateConstFieldInterfaceType(name string, constField string) string {
	return fmt.Sprintf(`
type %s interface{
    %s() string
	%s() ([]byte, error)
}`, name, strings.Title(constField), name)
}

func generateGenericInterfaceType(name string, hasSubtypes bool) string {
	if !hasSubtypes {
		return "\ntype " + name + " interface{}"
	}

	return fmt.Sprintf(`
type %s interface{
	%s() ([]byte, error)
}`, name, name)
}

func isSubtypeOf(tgType TypeDescription, parentType string) bool {
	for _, pt := range tgType.SubtypeOf {
		if parentType == pt {
			return true
		}
	}

	return false
}

type customConstStringData struct {
	Type              string
	ConstantFieldName string
	ConstantValueName string
}

const customConstStringField = `
func (v {{.Type}}) {{.ConstantFieldName}}() string {
	return "{{.ConstantValueName}}"
}
`

type customUnmarshalFieldData struct {
	Name    string
	Custom  bool
	Type    string
	JSONTag string
}

type customUnmarshalData struct {
	Type   string
	Fields []customUnmarshalFieldData
}

const customUnmarshal = `
func (v *{{.Type}}) UnmarshalJSON(b []byte) error {
	// All fields in {{.Type}}, with interface fields as json.RawMessage
	type tmp struct {
        {{ range $f := .Fields }}
		{{ $f.Name }} {{ if $f.Custom }} json.RawMessage {{ else }} {{ $f.Type }} {{ end }} {{ $f.JSONTag -}}
		{{- end }}
	}
	t := tmp{}
	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}
	{{ range $f := .Fields }}
		{{- if $f.Custom}}
			v.{{ $f.Name }}, err = unmarshal{{ $f.Type }}(t.{{$f.Name}})
			if err != nil {
				return err
			}
			{{- else }}
			v.{{ $f.Name }} = t.{{ $f.Name }}
		{{- end }}
	{{- end }}

	return nil
}
`

type customStructUnmarshalData struct {
	UnmarshalFuncName string
	ParentType        string
	ConstantFieldName string
	CaseStatements    []string
}

// The alias type is required to avoid infinite MarshalJSON loops.
const customStructUnmarshal = `func {{.UnmarshalFuncName}}(d json.RawMessage) ({{.ParentType}}, error) {
		if len(d) == 0 {
			return nil, nil
		}

		t := struct {
			{{.ConstantFieldName}} string
		}{}
		err := json.Unmarshal(d, &t)
		if err != nil {
			return nil, err
		}

		switch t.{{.ConstantFieldName}} {
		{{ range $val := .CaseStatements }} {{ $val }}
		{{end}}
		}
		return nil, errors.New("failed to unmarshal: unknown interface with {{.ConstantFieldName}} " +t.{{.ConstantFieldName}} )
}`

type customStructUnmarshalCaseData struct {
	ConstantFieldName string
	TypeName          string
}

// The alias type is required to avoid infinite MarshalJSON loops.
const customStructUnmarshalCase = `case "{{.ConstantFieldName}}":
	s := {{.TypeName}}{}
	err := json.Unmarshal(d, &s)
	if err != nil {
		return nil, err
	}
	return s, nil
`

type customMarshalData struct {
	Type                  string
	ConstantFieldName     string
	ConstantJSONFieldName string
	ConstantValueName     string
}

// The alias type is required to avoid infinite MarshalJSON loops.
const customMarshal = `
func (v {{.Type}}) MarshalJSON() ([]byte, error) {
	type alias {{.Type}}
	a := struct{
		{{.ConstantFieldName}} string ` + "`json:\"{{.ConstantJSONFieldName}}\"`" + `
		alias
	}{
		{{.ConstantFieldName}}: "{{.ConstantValueName}}",
		alias: (alias)(v),
	}
	return json.Marshal(a)
}
`

type interfaceMethodData struct {
	Type       string
	ParentType string
}

const inputMediaInterfaceMethod = `
func (v {{.Type}}) {{.ParentType}}Params(mediaName string, data map[string]NamedReader) ([]byte, error) {
	if v.Media != nil {
		switch m := v.Media.(type) {
		case string:
			// ok, noop

		case NamedReader:
			v.Media = "attach://" + mediaName
			data[mediaName] = m

		case io.Reader:
			v.Media = "attach://" + mediaName
			data[mediaName] = NamedFile{File: m}

		default:
			return nil, fmt.Errorf("unknown type for InputMedia: %T", v.Media)
		}
	}
	
	return json.Marshal(v)
}
`

const genericInterfaceMethod = `
func (v {{.Type}}) {{.ParentType}}() ([]byte, error) {
	return json.Marshal(v)
}
`
